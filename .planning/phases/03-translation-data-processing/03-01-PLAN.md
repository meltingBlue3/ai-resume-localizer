---
phase: 03-translation-data-processing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/models/resume.py
  - backend/app/models/api.py
  - backend/app/config.py
  - backend/.env.example
  - backend/app/services/dify_client.py
  - backend/app/api/routes/translate.py
  - backend/app/api/router.py
autonomous: true
user_setup:
  - service: dify-translation
    why: "AI translation of Chinese resume fields to Japanese (separate from extraction workflow)"
    env_vars:
      - name: DIFY_TRANSLATION_API_KEY
        source: "Dify Cloud → Studio → Your translation workflow → API Access → API Key"
    dashboard_config:
      - task: "Create a Dify workflow with input variable `cn_resume_json` (string) and output variable `jp_resume_json` (string containing valid JSON). The workflow should translate all Chinese resume fields to natural Japanese business language with keigo applied, and include name_katakana (katakana reading of the Chinese name) in the output."
        location: "Dify Cloud → Studio → Create Workflow"

must_haves:
  truths:
    - "POST /api/translate returns 200 with jp_resume JSON object when given valid CnResumeData"
    - "Missing DIFY_TRANSLATION_API_KEY returns HTTP 503 (same pattern as extraction)"
    - "JpResumeData Pydantic model mirrors CnResumeData structure and includes name_katakana field"
    - "Dify response jp_resume_json (string) is parsed to JpResumeData via model_validate()"
  artifacts:
    - path: "backend/app/models/resume.py"
      provides: "JpResumeData Pydantic model with all-nullable fields + name_katakana"
      contains: "class JpResumeData"
    - path: "backend/app/api/routes/translate.py"
      provides: "POST /api/translate endpoint"
      exports: ["router"]
    - path: "backend/app/services/dify_client.py"
      provides: "translate_resume() async method on DifyClient"
      contains: "async def translate_resume"
  key_links:
    - from: "backend/app/api/routes/translate.py"
      to: "backend/app/services/dify_client.py"
      via: "dify_client.translate_resume(cn_resume_json)"
      pattern: "translate_resume"
    - from: "backend/app/services/dify_client.py"
      to: "Dify API"
      via: "httpx POST with DIFY_TRANSLATION_API_KEY"
      pattern: "dify_translation_api_key"
    - from: "backend/app/api/router.py"
      to: "backend/app/api/routes/translate.py"
      via: "router.include_router"
      pattern: "include_router.*translate"
---

<objective>
Extend the backend with a complete translation pipeline: JpResumeData Pydantic schema, TranslateRequest/TranslateResponse API models, DifyClient.translate_resume() method, and the POST /api/translate endpoint registered in the router.

Purpose: Phase 3 depends on this endpoint — the frontend will POST cnResumeData and receive jpResumeData in return. This plan establishes the data contract and the backend plumbing before any frontend work begins.
Output: Working POST /api/translate endpoint that calls the Dify translation workflow and returns structured JpResumeData JSON.
</objective>

<execution_context>
@C:/Users/zhang/.config/opencode/get-shit-done/workflows/execute-plan.md
@C:/Users/zhang/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-translation-data-processing/03-RESEARCH.md
@.planning/phases/02-upload-extraction/02-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: JpResumeData Pydantic models, API models, and config expansion</name>
  <files>
    backend/app/models/resume.py
    backend/app/models/api.py
    backend/app/config.py
    backend/.env.example
  </files>
  <action>
**resume.py** — Add JpResumeData and nested models below the existing CnResumeData definitions:

```python
class JpPersonalInfo(BaseModel):
    name: Optional[str] = None           # Japanese name (kanji or transliterated)
    name_katakana: Optional[str] = None  # Katakana reading — Dify generates this
    birth_date: Optional[str] = None     # YYYY/MM Gregorian (displayed as wareki in frontend)
    gender: Optional[str] = None
    nationality: Optional[str] = None
    address: Optional[str] = None
    phone: Optional[str] = None
    email: Optional[str] = None
    linkedin: Optional[str] = None
    website: Optional[str] = None

class JpEducationEntry(BaseModel):
    school: Optional[str] = None
    degree: Optional[str] = None         # Dify returns Japanese equivalent; frontend also shows mapDegreeToJapanese()
    major: Optional[str] = None
    start_date: Optional[str] = None     # YYYY/MM Gregorian
    end_date: Optional[str] = None       # YYYY/MM Gregorian
    gpa: Optional[str] = None
    notes: Optional[str] = None

class JpWorkEntry(BaseModel):
    company: Optional[str] = None
    title: Optional[str] = None
    start_date: Optional[str] = None     # YYYY/MM Gregorian
    end_date: Optional[str] = None       # YYYY/MM Gregorian
    location: Optional[str] = None
    responsibilities: Optional[List[str]] = None
    achievements: Optional[List[str]] = None

class JpSkillEntry(BaseModel):
    category: Optional[str] = None
    skills: Optional[List[str]] = None

class JpCertificationEntry(BaseModel):
    name: Optional[str] = None
    issuer: Optional[str] = None
    date: Optional[str] = None           # YYYY/MM Gregorian
    score: Optional[str] = None

class JpResumeData(BaseModel):
    personal_info: Optional[JpPersonalInfo] = None
    summary: Optional[str] = None        # 自己PR / 職務概要 in keigo/です・ます form
    work_history: Optional[List[JpWorkEntry]] = None
    education: Optional[List[JpEducationEntry]] = None
    skills: Optional[List[JpSkillEntry]] = None
    certifications: Optional[List[JpCertificationEntry]] = None
    motivation: Optional[str] = None     # 志望動機 in humble form (謙譲語)
    strengths: Optional[str] = None
    other: Optional[str] = None
```

All List fields use `Optional[List[...]] = None`. Import List from typing (or use built-in `list` if Python 3.9+; check existing resume.py imports and match the pattern).

**api.py** — Add below existing UploadAndExtractResponse:

```python
class TranslateRequest(BaseModel):
    cn_resume: CnResumeData

class TranslateResponse(BaseModel):
    jp_resume: JpResumeData
```

Import CnResumeData and JpResumeData from models.resume.

**config.py** — Add `dify_translation_api_key: Optional[str] = None` to the Settings class, directly below `dify_extraction_api_key`. Match the existing field pattern exactly.

**.env.example** — Add below DIFY_EXTRACTION_API_KEY:
```
DIFY_TRANSLATION_API_KEY=your-translation-workflow-api-key-here
```
  </action>
  <verify>
Run: `cd backend && python -c "from app.models.resume import JpResumeData; from app.models.api import TranslateRequest, TranslateResponse; from app.config import settings; print('JpResumeData OK, TranslateRequest OK, settings.dify_translation_api_key:', settings.dify_translation_api_key)"`
Expected: Imports succeed, settings field prints (None if not set in .env, that is expected).
  </verify>
  <done>
JpResumeData and all nested Jp* models importable with no errors. TranslateRequest and TranslateResponse importable. settings.dify_translation_api_key field exists.
  </done>
</task>

<task type="auto">
  <name>Task 2: DifyClient.translate_resume() method, POST /api/translate endpoint, router registration</name>
  <files>
    backend/app/services/dify_client.py
    backend/app/api/routes/translate.py
    backend/app/api/router.py
  </files>
  <action>
**dify_client.py** — Add translate_resume() async method to the DifyClient class below extract_resume():

```python
async def translate_resume(self, cn_resume_json: str) -> dict:
    """Call Dify translation workflow. Returns parsed jp_resume dict."""
    api_key = settings.dify_translation_api_key
    if not api_key:
        raise HTTPException(status_code=503, detail="DIFY_TRANSLATION_API_KEY not configured")

    headers = {"Authorization": f"Bearer {api_key}", "Content-Type": "application/json"}
    payload = {
        "inputs": {"cn_resume_json": cn_resume_json},
        "response_mode": "blocking",
        "user": "resume-localizer",
    }

    try:
        async with httpx.AsyncClient(timeout=httpx.Timeout(90.0, connect=10.0)) as client:
            response = await client.post(
                f"{settings.dify_base_url}/workflows/run",
                headers=headers,
                json=payload,
            )
            response.raise_for_status()
    except httpx.TimeoutException:
        raise HTTPException(status_code=504, detail="Dify translation workflow timed out")
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=502, detail=f"Dify API error: {e.response.status_code}")
    except httpx.RequestError as e:
        raise HTTPException(status_code=502, detail=f"Dify connection error: {str(e)}")

    data = response.json()
    outputs = data.get("data", {}).get("outputs", {})
    jp_resume_json = outputs.get("jp_resume_json")
    if not jp_resume_json:
        raise HTTPException(status_code=502, detail="Dify translation returned no jp_resume_json output")

    try:
        return json.loads(jp_resume_json)
    except json.JSONDecodeError:
        raise HTTPException(status_code=502, detail="Dify jp_resume_json is not valid JSON")
```

Check that `json` is imported at the top of dify_client.py — add `import json` if missing. Check that `settings` and `HTTPException` are already imported (they should be from the extract_resume pattern) — import if missing.

**routes/translate.py** — Create new file:

```python
from fastapi import APIRouter
from app.models.api import TranslateRequest, TranslateResponse
from app.models.resume import JpResumeData
from app.services.dify_client import DifyClient

router = APIRouter()
dify_client = DifyClient()

@router.post("/api/translate", response_model=TranslateResponse)
async def translate_resume(request: TranslateRequest):
    cn_resume_json = request.cn_resume.model_dump_json()
    jp_resume_dict = await dify_client.translate_resume(cn_resume_json)
    jp_resume = JpResumeData.model_validate(jp_resume_dict)
    return TranslateResponse(jp_resume=jp_resume)
```

**router.py** — Add translate router alongside upload router:

```python
from app.api.routes.translate import router as translate_router
# ...existing upload include...
router.include_router(translate_router)
```

Match the existing include_router pattern exactly (no prefix argument — the route path is declared in translate.py).
  </action>
  <verify>
Run: `cd backend && python -c "from app.api.routes.translate import router; from app.api.router import router as api_router; routes = [r.path for r in api_router.routes]; print(routes)"` — confirm `/api/translate` appears in routes list.

Also: `cd backend && python -m uvicorn app.main:app --port 8001 &` then `curl -s http://localhost:8001/openapi.json | python -m json.tool | grep translate` — confirm POST /api/translate appears in OpenAPI spec.
  </verify>
  <done>
POST /api/translate appears in the FastAPI OpenAPI spec. DifyClient.translate_resume() method exists and follows the same timeout/error mapping pattern as extract_resume(). 503 returned when DIFY_TRANSLATION_API_KEY is not set (verifiable by temporarily unsetting the key).
  </done>
</task>

</tasks>

<verification>
1. `python -c "from app.models.resume import JpResumeData; print(JpResumeData.model_fields.keys())"` lists all expected fields.
2. `python -c "from app.api.routes.translate import router; print('OK')"` imports without errors.
3. OpenAPI spec at `/openapi.json` includes POST /api/translate with TranslateRequest body and TranslateResponse schema.
4. `.env.example` documents DIFY_TRANSLATION_API_KEY.
</verification>

<success_criteria>
- JpResumeData Pydantic model with 9 top-level fields, all nullable, including name_katakana via JpPersonalInfo
- TranslateRequest and TranslateResponse models in api.py
- DIFY_TRANSLATION_API_KEY in settings and .env.example
- DifyClient.translate_resume() method with identical timeout/error-mapping pattern to extract_resume()
- POST /api/translate endpoint registered and visible in OpenAPI spec
- All imports resolve with no circular dependency errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-translation-data-processing/03-01-SUMMARY.md`
</output>
