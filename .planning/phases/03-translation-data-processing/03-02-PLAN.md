---
phase: 03-translation-data-processing
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/types/resume.ts
  - frontend/src/utils/wareki.ts
  - frontend/src/utils/credentials.ts
  - frontend/src/stores/useResumeStore.ts
  - frontend/src/api/client.ts
  - frontend/package.json
autonomous: true

must_haves:
  truths:
    - "toWareki('2019/05') returns '令和元年5月' (gannen edge case)"
    - "toWareki('1990/03') returns '平成2年3月'"
    - "toWareki(null) returns empty string without throwing"
    - "mapDegreeToJapanese('本科') returns '大学卒業（学士）'"
    - "mapDegreeToJapanese('unknown') returns the original input unchanged"
    - "useResumeStore has jpResumeData, setJpResumeData, isTranslating, translationError fields"
    - "translateResume() API client POSTs to /api/translate and returns JpResumeData"
  artifacts:
    - path: "frontend/src/utils/wareki.ts"
      provides: "toWareki() conversion function"
      exports: ["toWareki"]
    - path: "frontend/src/utils/credentials.ts"
      provides: "mapDegreeToJapanese() lookup function"
      exports: ["mapDegreeToJapanese"]
    - path: "frontend/src/types/resume.ts"
      provides: "JpResumeData TypeScript interfaces"
      contains: "JpResumeData"
    - path: "frontend/src/stores/useResumeStore.ts"
      provides: "jpResumeData slice with isTranslating and error state"
      contains: "jpResumeData"
    - path: "frontend/src/api/client.ts"
      provides: "translateResume() typed fetch function"
      contains: "translateResume"
  key_links:
    - from: "frontend/src/api/client.ts"
      to: "/api/translate"
      via: "fetch POST with JSON body {cn_resume: CnResumeData}"
      pattern: "translateResume"
    - from: "frontend/src/stores/useResumeStore.ts"
      to: "frontend/src/api/client.ts"
      via: "translateResume() called in translate action"
      pattern: "translateResume"
---

<objective>
Build the frontend data layer for Phase 3: TypeScript types mirroring JpResumeData, wareki conversion utility, Japanese credential mapping utility, Zustand store expansion with translation state, and the translateResume API client function.

Purpose: This plan runs in parallel with 03-01. Together they establish the full data contract before the UI is built in 03-03. No UI work here — pure data layer.
Output: All utilities, types, and state management required by the ReviewTranslationStep and JpResumeFieldEditor components.
</objective>

<execution_context>
@C:/Users/zhang/.config/opencode/get-shit-done/workflows/execute-plan.md
@C:/Users/zhang/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-translation-data-processing/03-RESEARCH.md
@.planning/phases/02-upload-extraction/02-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: TypeScript JpResumeData types, wareki.ts utility, credentials.ts utility</name>
  <files>
    frontend/src/types/resume.ts
    frontend/src/utils/wareki.ts
    frontend/src/utils/credentials.ts
  </files>
  <action>
**types/resume.ts** — Append JpResumeData interfaces below existing CnResumeData interfaces. Mirror the Pydantic models from 03-01 exactly (snake_case field names, all optional):

```typescript
export interface JpPersonalInfo {
  name?: string | null;
  name_katakana?: string | null;
  birth_date?: string | null;   // YYYY/MM Gregorian
  gender?: string | null;
  nationality?: string | null;
  address?: string | null;
  phone?: string | null;
  email?: string | null;
  linkedin?: string | null;
  website?: string | null;
}

export interface JpEducationEntry {
  school?: string | null;
  degree?: string | null;
  major?: string | null;
  start_date?: string | null;   // YYYY/MM Gregorian
  end_date?: string | null;     // YYYY/MM Gregorian
  gpa?: string | null;
  notes?: string | null;
}

export interface JpWorkEntry {
  company?: string | null;
  title?: string | null;
  start_date?: string | null;   // YYYY/MM Gregorian
  end_date?: string | null;     // YYYY/MM Gregorian
  location?: string | null;
  responsibilities?: string[] | null;
  achievements?: string[] | null;
}

export interface JpSkillEntry {
  category?: string | null;
  skills?: string[] | null;
}

export interface JpCertificationEntry {
  name?: string | null;
  issuer?: string | null;
  date?: string | null;         // YYYY/MM Gregorian
  score?: string | null;
}

export interface JpResumeData {
  personal_info?: JpPersonalInfo | null;
  summary?: string | null;
  work_history?: JpWorkEntry[] | null;
  education?: JpEducationEntry[] | null;
  skills?: JpSkillEntry[] | null;
  certifications?: JpCertificationEntry[] | null;
  motivation?: string | null;
  strengths?: string | null;
  other?: string | null;
}
```

**utils/wareki.ts** — Create new file. Use browser-native Intl.DateTimeFormat (no library). Handle gannen (元年) edge case per research:

```typescript
/**
 * Converts a Gregorian date string (YYYY/MM or YYYY) to Japanese era format (和暦).
 * Dates are stored as Gregorian; wareki is computed on display only.
 * 
 * Era boundaries:
 *   令和: 2019-05-01 onwards
 *   平成: 1989-01-08 to 2019-04-30
 *   昭和: 1926-12-25 to 1989-01-07
 */
export function toWareki(gregorianDate: string | null | undefined): string {
  if (!gregorianDate) return '';

  const parts = gregorianDate.split('/');
  const year = parseInt(parts[0], 10);
  const month = parts[1] ? parseInt(parts[1], 10) : 1;

  if (isNaN(year)) return gregorianDate;

  const date = new Date(year, month - 1, 1);

  try {
    const formatted = new Intl.DateTimeFormat('ja-JP-u-ca-japanese', {
      era: 'long',
      year: 'numeric',
      month: 'numeric',
    }).format(date);

    // Gannen edge case: replace "1年" at the era year position with "元年"
    // Intl formats it as "令和1年" or "平成1年" — normalize to "元年"
    const gannenFixed = formatted.replace(/(\p{Script=Han}+)1年/u, '$1元年');

    // If input was year-only, strip month from result
    if (!parts[1]) {
      return gannenFixed.replace(/\d+月$/, '').trim();
    }

    return gannenFixed;
  } catch {
    return gregorianDate;
  }
}
```

**utils/credentials.ts** — Create new file with static lookup table:

```typescript
const DEGREE_MAP: Record<string, string> = {
  '本科': '大学卒業（学士）',
  '学士': '大学卒業（学士）',
  '专科': '短期大学卒業',
  '大专': '短期大学卒業',
  '硕士': '大学院修了（修士）',
  '研究生': '大学院修了（修士）',
  '博士': '大学院修了（博士）',
  '高中': '高等学校卒業',
  '高职': '専門学校卒業',
  '中专': '専門学校卒業',
};

/**
 * Maps Chinese education credential strings to standard Japanese equivalents.
 * Returns the original value unchanged if no mapping exists.
 */
export function mapDegreeToJapanese(degree: string | null | undefined): string {
  if (!degree) return '';
  return DEGREE_MAP[degree.trim()] ?? degree;
}
```
  </action>
  <verify>
Run: `cd frontend && npx tsc --noEmit` — no TypeScript errors in types/resume.ts.

Manual verification in browser console or vitest (if configured):
- `toWareki('2019/05')` should return a string containing '令和元年'
- `toWareki('1990/03')` should return a string containing '平成'
- `mapDegreeToJapanese('本科')` should return '大学卒業（学士）'
- `mapDegreeToJapanese('xyz')` should return 'xyz'
  </verify>
  <done>
JpResumeData and nested interfaces exported from types/resume.ts with no TypeScript errors. wareki.ts exports toWareki(). credentials.ts exports mapDegreeToJapanese(). Both utilities handle null/undefined gracefully without throwing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Zustand store expansion, translateResume API client, install @radix-ui/react-tooltip</name>
  <files>
    frontend/src/stores/useResumeStore.ts
    frontend/src/api/client.ts
    frontend/package.json
  </files>
  <action>
**Install** @radix-ui/react-tooltip (needed by 03-03 but install here to keep package.json changes in one plan):
```
npm install @radix-ui/react-tooltip
```

**useResumeStore.ts** — Expand the existing store. Import JpResumeData from types/resume.ts. Add to the store interface:

```typescript
// Translation state
jpResumeData: JpResumeData | null;
setJpResumeData: (data: JpResumeData) => void;
isTranslating: boolean;
setIsTranslating: (loading: boolean) => void;
translationError: string | null;
setTranslationError: (error: string | null) => void;
```

Add corresponding implementations in the create() call, following the same pattern as the extraction state fields (setIsExtracting, setExtractionError, etc.).

Add to initialState:
```typescript
jpResumeData: null,
isTranslating: false,
translationError: null,
```

Include jpResumeData, isTranslating, translationError in the reset action (spread from initialState).

Do NOT add a translate() action that calls the API — keep store as pure state. The step component will call the API client and then call setJpResumeData. This mirrors how UploadStep calls uploadAndExtract() directly without a store action.

**client.ts** — Add translateResume function below uploadAndExtract. Import CnResumeData and JpResumeData from types/resume.ts:

```typescript
export async function translateResume(cnResume: CnResumeData): Promise<JpResumeData> {
  const response = await fetch('/api/translate', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ cn_resume: cnResume }),
  });

  if (!response.ok) {
    let detail = 'Translation failed';
    try {
      const err = await response.json();
      detail = err.detail ?? detail;
    } catch {
      // ignore parse error
    }
    throw new Error(detail);
  }

  const data = await response.json();
  return data.jp_resume as JpResumeData;
}
```

Match the exact style and error handling of the existing uploadAndExtract function — same try/catch for detail extraction, same casting pattern.
  </action>
  <verify>
Run: `cd frontend && npx tsc --noEmit` — no TypeScript errors.
Run: `cd frontend && npm list @radix-ui/react-tooltip` — confirms package installed.
Check useResumeStore: `grep -n "jpResumeData\|isTranslating\|translationError" frontend/src/stores/useResumeStore.ts` — all three fields visible in both interface and initialState.
  </verify>
  <done>
useResumeStore has jpResumeData (JpResumeData | null), isTranslating (boolean), translationError (string | null) with getters and setters. translateResume() exported from api/client.ts with typed return. @radix-ui/react-tooltip in package.json dependencies. TypeScript compilation passes.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` in frontend directory passes with no errors.
2. `npm list @radix-ui/react-tooltip` shows installed version.
3. Grep confirms JpResumeData in types/resume.ts, toWareki in wareki.ts, mapDegreeToJapanese in credentials.ts, jpResumeData in useResumeStore.ts, translateResume in client.ts.
4. toWareki handles gannen case: '2019/05' → contains '元年'.
</verification>

<success_criteria>
- JpResumeData TypeScript interfaces match JpResumeData Pydantic models field-for-field
- toWareki() correctly handles YYYY/MM input, null/undefined, and gannen (元年) edge case
- mapDegreeToJapanese() covers 10 Chinese degree variants including common aliases
- useResumeStore has translation state slice (jpResumeData, isTranslating, translationError) included in reset
- translateResume() API client POSTs to /api/translate and returns typed JpResumeData
- @radix-ui/react-tooltip installed and in package.json
- Zero TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-translation-data-processing/03-02-SUMMARY.md`
</output>
