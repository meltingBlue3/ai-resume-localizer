# Phase 3: Translation & Data Processing - Research

**Researched:** 2026-02-18
**Domain:** Dify AI translation workflow, Japanese-specific data transformations (furigana, 和暦, credential mapping), side-by-side editable review UI, accessible tooltips
**Confidence:** HIGH (core patterns), MEDIUM (Dify translation workflow design)

---

## Summary

Phase 3 is the translation and data-processing heart of the pipeline: it takes `CnResumeData` (produced and reviewed in Phase 2) as input, sends it through a Dify translation workflow, applies Japanese-specific data transformations (furigana generation, 和暦 date conversion, credential mapping), and presents the result in a side-by-side review UI where the user can edit any field before proceeding to PDF generation.

The phase has three distinct layers: (1) a new backend FastAPI route `POST /api/translate` with a new `JpResumeData` Pydantic schema and a new `DifyClient.translate_resume()` method — all following the exact same pattern as Phase 2's extraction pipeline; (2) client-side data-processing utilities implemented as pure TypeScript functions (`toWareki()` for 和暦 conversion using the browser-native `Intl.DateTimeFormat` API, a static credential lookup table for degree mapping); (3) a `ReviewTranslationStep` replacement with a `JpResumeFieldEditor` component that mirrors `ResumeFieldEditor` but shows Chinese data read-only on the left and editable Japanese fields on the right, with `@radix-ui/react-tooltip` tooltips delivering culture tips at key fields.

The most critical architectural insight: **the `name_katakana` furigana field is best generated by the Dify translation workflow**, not by a client-side library pipeline (`pinyin` + `wanakana`). There is no standard pinyin→katakana library: wanakana converts Hepburn romaji to katakana (not pinyin), and pinyin syllables like `zh`, `ch`, `x`, `q` have no direct 1:1 hepburn equivalent. LLMs handle Chinese name→katakana conversion natively and accurately. The field must be editable (TRAN-04 already requires all fields editable), so any LLM imprecision is correctable.

**Primary recommendation:** Build in three plans: (1) backend translation endpoint + JpResumeData schema, (2) data-processing utilities + store expansion + frontend API client, (3) review translation UI with tooltips.

---

## Standard Stack

### Core (Phase 3 Additions)

| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| @radix-ui/react-tooltip | 1.2.8 | Accessible tooltip for culture tips (TRAN-08) | WAI-ARIA compliant, 7.1M weekly downloads, React 19 compatible (`^19.0` peer dep verified). Zero predefined styles — styled with Tailwind. |
| Intl.DateTimeFormat | Browser native | 和暦 date conversion (DOCG-06) | Browser-native, no library. `ja-JP-u-ca-japanese` calendar locale handles all era boundaries and gannen (元年) correctly in Chrome 24+, Firefox 29+, Safari 10+. |

### Existing (No Changes)

| Library | Version | Role |
|---------|---------|------|
| React | 19.2.x | Frontend framework |
| Tailwind CSS | 4.x | Styling |
| Zustand | 5.0.x | State store (expanded in 03-02) |
| react-i18next | 16.x | i18n for UI labels AND culture tip content |
| FastAPI | 0.115.8 | Backend API |
| httpx | 0.28.1 | Dify API client (existing `DifyClient` class) |
| Pydantic | via FastAPI | New `JpResumeData` models |

### Alternatives Considered

| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| @radix-ui/react-tooltip | Pure CSS Tailwind `group-hover:` tooltip | CSS tooltips are less accessible (no keyboard/focus support, no ARIA roles). Radix is worth the 12 transitive dependencies for a professional tool. |
| Intl.DateTimeFormat | `koyomi` or `wareki-conv` npm libraries | Native API handles all era boundaries and gannen with no dependency. Libraries add bundle weight without benefit. |
| Dify for furigana | `pinyin` + `wanakana` client-side | Pinyin and Hepburn romaji are different systems. `wanakana.toKatakana()` converts Hepburn, not pinyin — incorrect output for `zh/ch/x/q` syllables without a custom syllable map. LLM-generated furigana (via Dify) is accurate and editable. |

### Installation (Phase 3 Additions)

```bash
# Frontend only
cd frontend
npm install @radix-ui/react-tooltip
```

No new backend Python packages required — the existing `httpx`, `pydantic`, and `FastAPI` stack is sufficient.

---

## Architecture Patterns

### Recommended Project Structure (Phase 3 Additions)

```
ai-resume-localizer/
├── frontend/src/
│   ├── api/
│   │   └── client.ts              # EXPAND: add translateResume()
│   ├── components/
│   │   ├── review/
│   │   │   └── JpResumeFieldEditor.tsx  # NEW: Japanese editable form (right panel)
│   │   └── ui/
│   │       └── FieldTooltip.tsx   # NEW: Radix tooltip wrapper for culture tips
│   ├── steps/
│   │   └── ReviewTranslationStep.tsx    # REPLACE: Real side-by-side review
│   ├── stores/
│   │   └── useResumeStore.ts      # EXPAND: add jpResumeData slice
│   ├── types/
│   │   └── resume.ts              # EXPAND: add JpResumeData interfaces
│   └── utils/
│       ├── wareki.ts              # NEW: 和暦 date conversion utility
│       └── credentials.ts         # NEW: Chinese→Japanese degree mapping
├── backend/app/
│   ├── api/
│   │   ├── router.py              # EXPAND: register translate route
│   │   └── routes/
│   │       └── translate.py       # NEW: POST /api/translate
│   ├── services/
│   │   └── dify_client.py         # EXPAND: add translate_resume()
│   ├── models/
│   │   ├── resume.py              # EXPAND: add JpResumeData models
│   │   └── api.py                 # EXPAND: add TranslateRequest/Response
│   └── config.py                  # EXPAND: add dify_translation_api_key
```

### Pattern 1: DifyClient Method Extension (same pattern as extract_resume)

**What:** Add `translate_resume()` to the existing `DifyClient` class. It calls a DIFFERENT Dify workflow application (separate API key) with `cn_resume_json` as input and expects `jp_resume_json` as output.

**When to use:** Phase 3 translation call only. Separate API key = separate Dify workflow app.

```python
# backend/app/services/dify_client.py (addition)
async def translate_resume(self, cn_resume_data: dict, user: str = "default") -> dict:
    """Send Chinese resume data to Dify translation workflow and return Japanese data.

    Returns:
        Parsed dict from the workflow's jp_resume_json output.

    Raises:
        DifyWorkflowError: If the workflow fails or returns unexpected data.
        httpx.HTTPStatusError: If the HTTP request fails.
    """
    payload = {
        "inputs": {"cn_resume_json": json.dumps(cn_resume_data, ensure_ascii=False)},
        "response_mode": "blocking",
        "user": user,
    }

    response = await self._http.post("/workflows/run", json=payload)
    response.raise_for_status()

    data = response.json().get("data", {})
    if data.get("status") != "succeeded":
        raise DifyWorkflowError(f"Dify translation failed: {data.get('error', 'Unknown error')}")

    outputs = data.get("outputs", {})
    jp_data = outputs.get("jp_resume_json")

    if jp_data is None:
        raise DifyWorkflowError("Dify workflow returned no 'jp_resume_json' output")

    if isinstance(jp_data, str):
        try:
            jp_data = json.loads(jp_data)
        except json.JSONDecodeError as exc:
            raise DifyWorkflowError(f"Failed to parse jp_resume_json: {exc}") from exc

    return jp_data
```

### Pattern 2: JpResumeData Schema (mirrors CnResumeData + JP-specific additions)

**What:** New Pydantic model parallel to `CnResumeData`. Fields contain Japanese text output by Dify. Adds `name_katakana` (フリガナ) as a new field not present in `CnResumeData`. Degree fields are translated to Japanese equivalents by the Dify workflow.

**Design rationale:** Dates are stored as-received from Dify (typically "YYYY年MM月" or "YYYY/MM" depending on workflow design). 和暦 conversion is applied client-side in the utility layer before display/editing, not baked into the schema.

```python
# backend/app/models/resume.py (additions)
class JpEducationEntry(BaseModel):
    school: str | None = None       # 学校名 (Japanese)
    major: str | None = None        # 専攻 (Japanese)
    degree: str | None = None       # 学士/修士/博士/短期大学卒業 etc.
    start_date: str | None = None   # YYYY/MM or YYYY年MM月
    end_date: str | None = None

class JpWorkEntry(BaseModel):
    company: str | None = None      # 会社名 (Japanese translation or transliteration)
    position: str | None = None     # 役職 (Japanese)
    department: str | None = None   # 部署 (Japanese)
    start_date: str | None = None
    end_date: str | None = None
    description: str | None = None  # 職務内容 (Japanese, keigo/です-ます form)

class JpSkillEntry(BaseModel):
    name: str | None = None         # スキル名
    level: str | None = None        # 習熟度 (Japanese)

class JpCertificationEntry(BaseModel):
    name: str | None = None
    date: str | None = None

class JpResumeData(BaseModel):
    """Canonical schema for Japanese-translated resume data."""
    # Personal info
    name_kanji: str | None = None           # 氏名 (kanji, same or transliterated)
    name_katakana: str | None = None        # フリガナ (auto-generated by Dify)
    phone: str | None = None
    email: str | None = None
    date_of_birth: str | None = None        # YYYY/MM/DD (Gregorian, wareki computed from this)
    address: str | None = None              # 住所 (Japanese-formatted)
    nationality: str | None = None
    gender: str | None = None

    # Professional
    education: list[JpEducationEntry] | None = None
    work_experience: list[JpWorkEntry] | None = None
    skills: list[JpSkillEntry] | None = None
    certifications: list[JpCertificationEntry] | None = None
    languages: list[str] | None = None

    # Content (keigo language)
    self_introduction: str | None = None    # 自己PR (humble form, 謙譲語)
    career_objective: str | None = None     # 志望動機 (humble form)
    project_experience: list[JpWorkEntry] | None = None
    awards: list[str] | None = None
    hobbies: str | None = None              # 趣味・特技
```

### Pattern 3: 和暦 Date Conversion (browser-native, no library)

**What:** Pure TypeScript utility using `Intl.DateTimeFormat('ja-JP-u-ca-japanese', ...)` to convert Gregorian date strings to Japanese era format. Handles gannen (元年) correctly in modern browsers.

**Input formats:** "YYYY/MM", "YYYY-MM", "YYYY/MM/DD", "YYYY-MM-DD", or year-only "YYYY"

**Output formats:** "令和5年3月", "平成元年4月", "昭和63年12月"

```typescript
// frontend/src/utils/wareki.ts
// Source: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat

const YEAR_MONTH_RE = /^(\d{4})[\/\-](\d{1,2})(?:[\/\-]\d{1,2})?$/;
const YEAR_ONLY_RE = /^(\d{4})$/;

export function toWareki(dateStr: string | null | undefined): string {
  if (!dateStr) return '';

  let date: Date;
  const ymMatch = dateStr.match(YEAR_MONTH_RE);
  const yMatch = dateStr.match(YEAR_ONLY_RE);

  if (ymMatch) {
    const [, year, month] = ymMatch;
    date = new Date(Number(year), Number(month) - 1, 1);
  } else if (yMatch) {
    date = new Date(Number(yMatch[1]), 0, 1);
  } else {
    return dateStr; // Unrecognized format — return as-is
  }

  try {
    const fmt = new Intl.DateTimeFormat('ja-JP-u-ca-japanese', {
      era: 'long',
      year: 'numeric',
      month: 'long',
    });
    const parts = fmt.formatToParts(date);

    // Build "令和元年3月" or "平成5年9月" from parts
    const era = parts.find(p => p.type === 'era')?.value ?? '';
    const year = parts.find(p => p.type === 'year')?.value ?? '';
    const month = parts.find(p => p.type === 'month')?.value ?? '';

    // Normalize: Intl outputs "1年" for gannen era year in some browsers — convert to "元年"
    const yearDisplay = year === '1年' || year === '1' ? '元年' : year.endsWith('年') ? year : `${year}年`;
    const monthDisplay = month.endsWith('月') ? month : `${month}月`;

    if (ymMatch) {
      return `${era}${yearDisplay}${monthDisplay}`;
    } else {
      return `${era}${yearDisplay}`;
    }
  } catch {
    return dateStr; // Intl not supported — return as-is
  }
}

// Exported for use in JpResumeFieldEditor and PDF generation (Phase 4)
export function toWareikiYear(year: number): string {
  const date = new Date(year, 0, 1);
  const fmt = new Intl.DateTimeFormat('ja-JP-u-ca-japanese', { era: 'long', year: 'numeric' });
  const parts = fmt.formatToParts(date);
  const era = parts.find(p => p.type === 'era')?.value ?? '';
  const yr = parts.find(p => p.type === 'year')?.value ?? '';
  const yearDisplay = yr === '1年' || yr === '1' ? '元年' : yr.endsWith('年') ? yr : `${yr}年`;
  return `${era}${yearDisplay}`;
}
```

### Pattern 4: Chinese→Japanese Credential Mapping (static lookup)

**What:** Static lookup table for Chinese education degree terms → Japanese equivalents. Used client-side as post-processing normalization after Dify translation (Dify may translate correctly, but this ensures consistency).

```typescript
// frontend/src/utils/credentials.ts
const DEGREE_MAP: Record<string, string> = {
  // Simplified Chinese
  '本科': '大学卒業（学士）',
  '大学本科': '大学卒業（学士）',
  '学士': '大学卒業（学士）',
  '专科': '短期大学卒業',
  '大专': '短期大学卒業',
  '硕士': '大学院修了（修士）',
  '研究生': '大学院修了（修士）',
  '博士': '大学院修了（博士）',
  '高中': '高等学校卒業',
  '高职': '専門学校卒業',
  // Traditional Chinese variants
  '學士': '大学卒業（学士）',
  '碩士': '大学院修了（修士）',
  '高中': '高等学校卒業',
};

/**
 * Maps a Chinese degree string to its standard Japanese equivalent.
 * Returns the original string if no mapping found (Dify may have already translated it).
 */
export function mapDegreeToJapanese(degree: string | null): string | null {
  if (!degree) return null;
  return DEGREE_MAP[degree.trim()] ?? degree;
}
```

### Pattern 5: Side-by-Side Translation Review (mirrors ReviewExtractionStep)

**What:** `ReviewTranslationStep` shows Chinese data read-only on the left, editable Japanese data on the right. Left panel uses the existing `ResumeFieldEditor` in read-only mode; right panel uses new `JpResumeFieldEditor` with tooltips.

**Layout:** Identical grid layout to Phase 2: `grid h-[calc(100vh-20rem)] grid-cols-1 gap-4 lg:grid-cols-2`

```tsx
// frontend/src/steps/ReviewTranslationStep.tsx (simplified)
export default function ReviewTranslationStep() {
  const cnResumeData = useResumeStore(s => s.cnResumeData);
  const jpResumeData = useResumeStore(s => s.jpResumeData);
  const setJpResumeData = useResumeStore(s => s.setJpResumeData);
  const isTranslating = useResumeStore(s => s.isTranslating);

  // Trigger translation when cnResumeData is available and jpResumeData is null
  useEffect(() => {
    if (cnResumeData && !jpResumeData && !isTranslating) {
      runTranslation(cnResumeData);
    }
  }, [cnResumeData]);

  return (
    <div className="space-y-4">
      {/* Step header */}
      <div className="grid h-[calc(100vh-20rem)] grid-cols-1 gap-4 lg:grid-cols-2">
        {/* Left: Chinese data (read-only) */}
        <div className="flex flex-col overflow-hidden rounded-lg border border-slate-200">
          <div className="border-b border-slate-200 bg-slate-50 px-4 py-2.5">
            <h3 className="text-sm font-semibold text-slate-700">{t('steps.reviewTranslation.chineseData')}</h3>
          </div>
          <div className="flex-1 overflow-y-auto p-4">
            {cnResumeData && <ResumeFieldEditor data={cnResumeData} onChange={() => {}} readOnly />}
          </div>
        </div>

        {/* Right: Japanese data (editable) */}
        <div className="flex flex-col overflow-hidden rounded-lg border border-slate-200">
          <div className="border-b border-slate-200 bg-slate-50 px-4 py-2.5">
            <h3 className="text-sm font-semibold text-slate-700">{t('steps.reviewTranslation.japaneseData')}</h3>
          </div>
          <div className="flex-1 overflow-y-auto p-4">
            {isTranslating && <TranslationLoadingState />}
            {jpResumeData && (
              <JpResumeFieldEditor data={jpResumeData} onChange={setJpResumeData} />
            )}
          </div>
        </div>
      </div>
    </div>
  );
}
```

### Pattern 6: Radix Tooltip for Culture Tips (TRAN-08)

**What:** `@radix-ui/react-tooltip` wraps field labels in `JpResumeFieldEditor`. Culture tip content lives in i18n JSON files (keyed by field name). Tooltip icon (ℹ️ SVG) appears next to the label.

**Important:** `TooltipProvider` must wrap the application root (or the step component) — it controls delay behavior.

```tsx
// frontend/src/components/ui/FieldTooltip.tsx
// Source: https://www.radix-ui.com/primitives/docs/components/tooltip

import * as Tooltip from '@radix-ui/react-tooltip';

interface FieldTooltipProps {
  content: string;
  children: React.ReactNode;
}

export function FieldTooltip({ content, children }: FieldTooltipProps) {
  return (
    <Tooltip.Provider delayDuration={400}>
      <Tooltip.Root>
        <Tooltip.Trigger asChild>
          <span className="inline-flex cursor-help items-center gap-1">
            {children}
            <svg className="h-3.5 w-3.5 text-slate-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
          </span>
        </Tooltip.Trigger>
        <Tooltip.Portal>
          <Tooltip.Content
            className="max-w-xs rounded-lg bg-slate-800 px-3 py-2 text-xs text-white shadow-lg"
            sideOffset={5}
          >
            {content}
            <Tooltip.Arrow className="fill-slate-800" />
          </Tooltip.Content>
        </Tooltip.Portal>
      </Tooltip.Root>
    </Tooltip.Provider>
  );
}
```

### Anti-Patterns to Avoid

- **Using `pinyin` + `wanakana` for Chinese name → katakana:** wanakana converts Hepburn romaji, not Mandarin pinyin. Pinyin `zh`, `x`, `q`, `c` don't map correctly through wanakana — produces phonetically wrong katakana. Have Dify generate `name_katakana`.
- **Storing 和暦 dates in the database/schema:** Store Gregorian dates in `JpResumeData` (source of truth); compute wareki on display. This avoids era boundary bugs when displaying historical dates and keeps data pure.
- **Designing the Dify translation workflow with separate backend calls:** The "dual-node" design (core translation + localization) is configured entirely inside Dify Cloud UI — it's one workflow run from our backend's perspective. The backend makes one `POST /workflows/run` call.
- **Using blocking mode fetch without a timeout:** Same Cloudflare 100s timeout applies to the translation workflow. Reuse the existing 90s httpx timeout from `DifyClient.__init__`.
- **Building `JpResumeFieldEditor` from scratch:** It's ~90% identical to `ResumeFieldEditor`. Extract shared sub-components (`CollapsibleSection`, `FieldInput`, `AddButton`, `RemoveButton`) into `frontend/src/components/review/shared.tsx` and import in both editors.
- **Hardcoding culture tip text in JSX:** Culture tips must use `t()` — same i18n pattern as all other UI strings. Define them in `zh/wizard.json` and `ja/wizard.json` under `steps.reviewTranslation.cultureTips.*`.

---

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Accessible tooltips | Custom `onMouseEnter/Leave` + absolute-positioned div | `@radix-ui/react-tooltip` | Handles keyboard focus, ARIA roles, collision detection, portal rendering, escape key dismiss |
| 和暦 era conversion | Custom era boundary lookup table | `Intl.DateTimeFormat('ja-JP-u-ca-japanese', ...)` | Browser-native, handles all historical era transitions, supports gannen (元年), future-proof |
| Pinyin → katakana | Custom phonetic transliteration engine | Dify LLM output (`name_katakana` field) | Chinese→katakana requires phonetic approximation with cultural context; LLMs do this natively and accurately |
| Japanese business language | Custom prompt engineering in app code | Dify workflow with proper keigo instructions | Keigo selection is context-sensitive; belongs in the LLM prompt, not in application code |

**Key insight:** The Japanese-specific data problems (furigana, keigo, cultural naming conventions) are exactly what LLMs excel at. Resist the urge to build custom phonetic libraries — let Dify handle what LLMs do well, and use browser APIs for deterministic transformations (dates).

---

## Common Pitfalls

### Pitfall 1: Gannen (元年) Browser Output Inconsistency

**What goes wrong:** `Intl.DateTimeFormat` outputs "令和1年" instead of "令和元年" in some browser/OS combinations. The first year of an era is "gannen" (元年) in Japanese convention.

**Why it happens:** The ECMA-402 spec allows implementations to format year=1 as "1年" or "元年" depending on locale data version. Safari and Chrome may differ.

**How to avoid:** After formatting with `Intl`, check if the year part is "1年" or `"1"` and replace with `"元年"`:

```typescript
const yearDisplay = year === '1年' || year === '1' ? '元年' : year;
```

**Warning signs:** Dates in May 2019–December 2019 show "令和1年" instead of "令和元年". Test specifically with `new Date(2019, 4, 1)` (May 1, 2019, first day of Reiwa).

### Pitfall 2: Dify Translation Workflow Output Key Mismatch

**What goes wrong:** The backend code expects `outputs.jp_resume_json` but the Dify workflow is configured to output a variable named `translated_resume` or similar.

**Why it happens:** The Dify workflow output variable name is configured in the Dify Cloud UI — it's not enforced by the API. A mismatch causes `DifyWorkflowError("Dify workflow returned no 'jp_resume_json' output")`.

**How to avoid:** When creating the Dify translation workflow, explicitly name the output variable `jp_resume_json`. Document this in the project README. Add a clear error message that includes the expected key name to help with debugging.

**Warning signs:** `DifyWorkflowError` immediately after a "succeeded" status. Check `outputs` dict keys in the error log.

### Pitfall 3: JpResumeData Validation Failure from Dify Output

**What goes wrong:** Dify returns a JSON object where some fields have unexpected types (e.g., `education` is a dict instead of a list, or `date_of_birth` is an integer).

**Why it happens:** LLMs can hallucinate types even with a schema in the prompt. Pydantic's `model_validate()` will raise `ValidationError`.

**How to avoid:** Use `model_validate()` with `strict=False` (default) to allow coercion. Add a try/except around `JpResumeData.model_validate()` that logs the raw output and raises a `DifyWorkflowError` with a readable message. Consider `model_validate(jp_data, from_attributes=False)` with lenient field parsing.

**Warning signs:** `ValidationError` from pydantic in translation route. Raw Dify output logged shows valid JSON but with type mismatches.

### Pitfall 4: `name_katakana` Empty When Dify Omits It

**What goes wrong:** Some Chinese names use characters the LLM is uncertain about. Dify may omit `name_katakana` or return `null`.

**Why it happens:** LLMs are conservative when uncertain about phonetic readings of uncommon characters.

**How to avoid:** The `name_katakana` field in `JpResumeData` defaults to `null`. The `JpResumeFieldEditor` shows this field prominently with a placeholder and culture tip explaining its importance (Japanese employers require フリガナ on 履歴書). User can type it manually. This is acceptable given that TRAN-04 makes all fields editable.

**Warning signs:** `jpResumeData.name_katakana === null` after translation. Ensure the Dify workflow prompt explicitly instructs: "Output the katakana phonetic reading of the Chinese name in `name_katakana`. This is required on Japanese resumes."

### Pitfall 5: Side-by-Side Layout Scroll Sync

**What goes wrong:** Both panels scroll independently (correct behavior), but users find it confusing that the Chinese and Japanese panels lose alignment as they scroll.

**Why it happens:** Independent `overflow-y-auto` panels with different content heights (Japanese text is often more verbose than Chinese).

**How to avoid:** This is a known UX trade-off of the side-by-side pattern — same issue exists in Phase 2's extraction review. Accept it for v1. Add section headers at the top of both panels to orient the user. Future improvement: synchronized scroll (out of scope for Phase 3).

**Warning signs:** User testing feedback about losing their place when scrolling the Japanese panel.

### Pitfall 6: `ResumeFieldEditor` readOnly Mode Not Implemented

**What goes wrong:** Phase 2's `ResumeFieldEditor` was not built with a `readOnly` prop — all inputs are always editable. When reused in Phase 3's left panel (Chinese data), edits would mutate `cnResumeData` unintentionally.

**Why it happens:** Phase 2 only needed editable mode. Phase 3 reuses the same component.

**How to avoid:** Add a `readOnly?: boolean` prop to `ResumeFieldEditor`. When `readOnly={true}`, replace `<input>` and `<textarea>` with `<span>` or `disabled` inputs. Add/Remove buttons are hidden. This is a small change to an existing component.

**Warning signs:** Changes to the left panel persisting to the Zustand store and affecting translation input.

### Pitfall 7: `TooltipProvider` Missing from App Tree

**What goes wrong:** Radix tooltip content doesn't appear, or React throws an error about missing context.

**Why it happens:** `@radix-ui/react-tooltip` requires `<Tooltip.Provider>` as an ancestor of all `<Tooltip.Root>` components. If it's missing, tooltips silently fail or error.

**How to avoid:** Wrap `<Tooltip.Provider>` in `App.tsx` (at the top level), not per-instance. This is the correct Radix pattern and allows global delay configuration:

```tsx
// App.tsx
import * as Tooltip from '@radix-ui/react-tooltip';

function App() {
  return (
    <Tooltip.Provider delayDuration={500}>
      {/* rest of app */}
    </Tooltip.Provider>
  );
}
```

**Warning signs:** Console error: "Cannot read property 'delayDuration' of undefined" or tooltips not appearing.

---

## Code Examples

### FastAPI Translation Route

```python
# backend/app/api/routes/translate.py
import logging
import httpx
from fastapi import APIRouter, HTTPException
from app.config import settings
from app.models.api import TranslateRequest, TranslateResponse
from app.models.resume import JpResumeData
from app.services.dify_client import DifyClient, DifyWorkflowError

logger = logging.getLogger(__name__)
router = APIRouter()


@router.post("/api/translate", response_model=TranslateResponse)
async def translate_resume(body: TranslateRequest):
    """Translate Chinese resume data to Japanese via Dify translation workflow."""
    if not settings.dify_translation_api_key:
        raise HTTPException(
            status_code=503,
            detail="Dify translation API key not configured. Set DIFY_TRANSLATION_API_KEY.",
        )

    client = DifyClient(
        api_key=settings.dify_translation_api_key,
        base_url=settings.dify_base_url,
    )

    try:
        cn_dict = body.cn_resume_data.model_dump(mode="json")
        jp_dict = await client.translate_resume(cn_dict)
        jp_resume_data = JpResumeData.model_validate(jp_dict)
    except DifyWorkflowError as exc:
        logger.error("Dify translation failed: %s", exc)
        raise HTTPException(status_code=502, detail=str(exc)) from exc
    except httpx.HTTPStatusError as exc:
        logger.error("Dify API HTTP error: %s", exc)
        raise HTTPException(status_code=502, detail=f"Dify API returned {exc.response.status_code}") from exc
    except httpx.TimeoutException as exc:
        logger.error("Dify API timeout: %s", exc)
        raise HTTPException(status_code=504, detail="Dify translation API timed out") from exc
    finally:
        await client.close()

    return TranslateResponse(jp_resume_data=jp_resume_data)
```

### API Models

```python
# backend/app/models/api.py (additions)
from app.models.resume import CnResumeData, JpResumeData

class TranslateRequest(BaseModel):
    cn_resume_data: CnResumeData

class TranslateResponse(BaseModel):
    jp_resume_data: JpResumeData
```

### Config Extension

```python
# backend/app/config.py (addition to Settings class)
dify_translation_api_key: str = ""
```

```bash
# backend/.env (addition)
DIFY_TRANSLATION_API_KEY=app-xxxxxxxxxxxxxxxx
```

### Frontend API Client Addition

```typescript
// frontend/src/api/client.ts (addition)
import type { CnResumeData, JpResumeData } from '../types/resume';

export interface TranslateResponse {
  jp_resume_data: JpResumeData;
}

export async function translateResume(cnResumeData: CnResumeData): Promise<TranslateResponse> {
  const response = await fetch('/api/translate', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ cn_resume_data: cnResumeData }),
  });

  if (!response.ok) {
    const errorBody = await response.json().catch(() => null);
    throw new Error(errorBody?.detail ?? `Translation failed (${response.status})`);
  }

  return response.json() as Promise<TranslateResponse>;
}
```

### Zustand Store Expansion

```typescript
// frontend/src/stores/useResumeStore.ts (additions to interface and create())
import type { CnResumeData, JpResumeData } from '../types/resume';

interface ResumeState {
  // ... existing fields ...

  // Translation state (Phase 3)
  jpResumeData: JpResumeData | null;
  isTranslating: boolean;
  translationError: string | null;
  setJpResumeData: (data: JpResumeData) => void;
  setTranslating: (loading: boolean) => void;
  setTranslationError: (error: string | null) => void;
}

// In create():
jpResumeData: null,
isTranslating: false,
translationError: null,
setJpResumeData: (data) => set({ jpResumeData: data, translationError: null, isTranslating: false }),
setTranslating: (loading) => set({ isTranslating: loading }),
setTranslationError: (error) => set({ translationError: error, isTranslating: false }),
```

### TypeScript JpResumeData Interface

```typescript
// frontend/src/types/resume.ts (additions)
export interface JpEducationEntry {
  school: string | null;
  major: string | null;
  degree: string | null;   // e.g. "大学卒業（学士）"
  start_date: string | null;
  end_date: string | null;
}

export interface JpWorkEntry {
  company: string | null;
  position: string | null;
  department: string | null;
  start_date: string | null;
  end_date: string | null;
  description: string | null;
}

export interface JpSkillEntry {
  name: string | null;
  level: string | null;
}

export interface JpCertificationEntry {
  name: string | null;
  date: string | null;
}

export interface JpResumeData {
  name_kanji: string | null;
  name_katakana: string | null;   // フリガナ
  phone: string | null;
  email: string | null;
  date_of_birth: string | null;   // YYYY/MM/DD
  address: string | null;
  nationality: string | null;
  gender: string | null;
  education: JpEducationEntry[] | null;
  work_experience: JpWorkEntry[] | null;
  skills: JpSkillEntry[] | null;
  certifications: JpCertificationEntry[] | null;
  languages: string[] | null;
  self_introduction: string | null;
  career_objective: string | null;
  project_experience: JpWorkEntry[] | null;
  awards: string[] | null;
  hobbies: string | null;
}
```

### Culture Tips i18n Keys

```json
// frontend/src/i18n/locales/zh/wizard.json (additions under steps.reviewTranslation)
"reviewTranslation": {
  "title": "审核翻译",
  "description": "查看并编辑AI翻译的日文内容，确保翻译准确",
  "chineseData": "中文原文",
  "japaneseData": "日文译文",
  "translating": "AI正在翻译...",
  "translationError": "翻译失败",
  "retry": "重试",
  "fields": {
    "nameKanji": "氏名（汉字）",
    "nameKatakana": "フリガナ（片假名）",
    "dateOfBirth": "生年月日",
    "selfIntroduction": "自己PR",
    "careerObjective": "志望動機"
  },
  "cultureTips": {
    "nameKatakana": "日本简历必须填写姓名的片假名读音（フリガナ）。中文姓名需根据普通话发音转写为片假名。",
    "dateOfBirth": "日本简历通常使用和暦（令和/平成/昭和）表示出生日期。系统已自动转换。",
    "selfIntroduction": "自己PR应使用谦虚的敬语（谦譲語），重点突出为公司带来的价值，而非个人成就。",
    "careerObjective": "志望動機应体现对该公司的特定理由，避免通用表述。使用です/ます体。",
    "gender": "日本は2021年履歴書改訂以降、性別欄は任意記載となりました。"
  }
}
```

---

## Dify Translation Workflow Design Notes

The "dual-node" translation design is configured inside Dify Cloud UI — not in the backend code. From the backend's perspective, it's a single workflow run. The recommended Dify workflow structure:

**Node 1 (Core Translation):**
- Input: `cn_resume_json` (the full Chinese resume as JSON string)
- LLM prompt: Translate all Chinese text fields to Japanese. Preserve null fields as null. Output JSON conforming to `JpResumeData` schema. Generate `name_katakana` (フリガナ) from the Chinese name using standard Mandarin→katakana phonetic mapping.
- Output variable: `core_translation` (intermediate JSON string)

**Node 2 (Localization/Keigo):**
- Input: `core_translation` from Node 1
- LLM prompt: Review and improve the Japanese translation. Apply keigo: (a) 職務記述 sections → polite `です/ます` form; (b) 自己PR and 志望動機 → humble `謙譲語` form; (c) map education degrees to standard Japanese equivalents (本科→大学卒業（学士）, 硕士→大学院修了（修士）, etc.). Output the same JSON structure with improved language.
- Output variable: `jp_resume_json` (final JSON string expected by backend)

**Workflow configuration:**
- Response mode: `blocking` (same as extraction workflow)
- Input variable name: `cn_resume_json` (string type)
- Final output variable name: `jp_resume_json` (string type — backend calls `json.loads()` on it)
- Model: GPT-4o or Claude 3.5 Sonnet recommended for keigo accuracy
- Timeout: same 90s httpx limit applies

---

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| `import fitz` for PyMuPDF | `import pymupdf` | 2025 | Existing code already uses `pymupdf` correctly |
| Separate Dify client class per workflow | Single `DifyClient` with multiple methods | Phase 2 decision | `translate_resume()` is a new method, not a new class |
| Manual wareki conversion table | `Intl.DateTimeFormat('ja-JP-u-ca-japanese', ...)` | Modern browsers (2015+) | No library needed for Japanese calendar |
| Separate `TooltipProvider` per tooltip | Single global `TooltipProvider` in `App.tsx` | Radix v1.x convention | Must wrap entire app, not per-component |

**Deprecated/outdated:**
- `wanakana` for pinyin→katakana: wanakana handles Hepburn romaji, not Mandarin pinyin. The syllable systems are different — do not use for this conversion.
- Separate `DifyClient` class for translation: extend the existing class with a new method.

---

## Open Questions

1. **Dify translation workflow creation timing**
   - What we know: The Dify translation workflow must be created in Dify Cloud UI with the correct input/output variable names (`cn_resume_json` → `jp_resume_json`) before the backend can call it.
   - What's unclear: Whether the workflow already exists. What model is selected.
   - Recommendation: Plan 03-01 implementation should include a section on Dify workflow setup. Add a `.env` check at startup that logs a warning if `DIFY_TRANSLATION_API_KEY` is missing (same pattern as extraction key check in upload route).

2. **`name_katakana` quality for uncommon Chinese characters**
   - What we know: LLMs generally produce accurate katakana for common Chinese surnames (张→チャン, 王→ワン, 李→リー). Uncommon characters or compound names may produce uncertain results.
   - What's unclear: Whether to add a client-side fallback generation when `name_katakana` is null.
   - Recommendation: For v1, display the field prominently with a clear placeholder ("フリガナを入力してください"). The culture tip tooltip explains why it's required. User fills in manually if Dify leaves it null. No client-side library fallback needed in Phase 3.

3. **Gregorian vs. Wareki date storage in JpResumeData**
   - What we know: Phase 4 (PDF generation) needs 和暦 dates for 履歴書. DOCG-06 is assigned to Phase 3.
   - What's unclear: Should `JpResumeData` store dates in wareki format, Gregorian format, or both?
   - Recommendation: Store dates in Gregorian format (YYYY/MM or YYYY-MM) in `JpResumeData` — this is the source of truth. The `toWareki()` utility converts for display in `JpResumeFieldEditor` and in Phase 4's PDF template. This avoids parsing wareki strings back to dates later. The editable field in `JpResumeFieldEditor` shows the wareki string but stores the underlying Gregorian value in state — or alternatively, show wareki as a computed read-only display alongside an editable Gregorian input.

4. **`ResumeFieldEditor` readOnly prop**
   - What we know: The existing component has no readOnly prop.
   - What's unclear: Best UX for the left (Chinese) panel — disabled inputs, plain text display, or different component entirely.
   - Recommendation: Add `readOnly?: boolean` to `ResumeFieldEditor`. When true: replace inputs with `<p>` elements for clean read-only display. This is simpler than a separate component and reuses all the section/field structure.

---

## Sources

### Primary (HIGH confidence)
- Dify Workflow Execution API — https://docs.dify.ai/api-reference/workflow-execution/execute-workflow — OpenAPI spec confirmed: `inputs` object, `response_mode: blocking`, `data.outputs` structure
- @radix-ui/react-tooltip v1.2.8 — https://www.npmjs.com/package/@radix-ui/react-tooltip — React 19 peer dep `^19.0` confirmed, 7.1M weekly downloads
- Intl.DateTimeFormat MDN — https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat — `ja-JP-u-ca-japanese` calendar support, `era: 'long'` option confirmed
- Era boundary dates — verified: Reiwa 2019-05-01, Heisei 1989-01-08 to 2019-04-30, Showa 1926-12-25 to 1989-01-07
- wanakana v5.3.1 — https://wanakana.com/docs/index.html — `toKatakana()` converts Hepburn romaji, NOT pinyin (confirmed from docs — handles Japanese input only)
- pinyin v4 — https://pinyin.js.org/en-US/ — Chinese→Hepburn romanization; `mode: 'surname'` available; confirmed no direct katakana output
- Existing codebase — `DifyClient`, `useResumeStore`, `ResumeFieldEditor`, `ReviewExtractionStep` fully read — Phase 3 patterns directly mirror these

### Secondary (MEDIUM confidence)
- Gannen (元年) browser behavior — https://girliemac.com/blog/2019/04/02/javascript-i18n-reiwa-era — `Intl.DateTimeFormat` with `era: 'long'` handles gannen in modern browsers; year=1 may output "1年" not "元年" in some implementations (requires normalization workaround)
- Dify dual-node workflow pattern — https://hellodify.com/en/docs/workflow/node/multilingual-document-translator + https://docs.dify.ai/en/use-dify/nodes/variable-aggregator — Iteration + Variable Aggregator nodes for translation workflows confirmed; sequential/parallel modes verified

### Tertiary (LOW confidence)
- Pinyin→katakana mapping non-existence — "No standard mapping exists between pinyin and katakana" (Unicode CLDR confirms no pinyin→kana transform); LLM-based approach recommended based on domain knowledge; no official specification found
- Chinese degree→Japanese equivalent mapping — Based on domain knowledge of Japanese education system equivalencies; not from an official MoE standard document; needs validation with Japanese HR professionals

---

## Metadata

**Confidence breakdown:**
- Standard stack (libraries + native APIs): HIGH — all verified from npm registry and official docs
- Architecture (mirroring Phase 2 patterns): HIGH — existing code fully read and understood
- Dify workflow design (dual-node): MEDIUM — API confirmed, internal Dify node design is Dify Cloud concern
- Wareki conversion (Intl.DateTimeFormat): HIGH — MDN docs and browser support table verified; gannen edge case documented
- Pinyin→katakana (Dify approach): MEDIUM — LLM capability well-established but quality for uncommon characters untested
- Credential mapping table: LOW — domain knowledge, not from official Japanese MoE source

**Research date:** 2026-02-18
**Valid until:** 2026-03-18 (30 days — stable libraries, Dify API stable)
